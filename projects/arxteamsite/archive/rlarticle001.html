<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>
<head>
<head>
    <link href="default.css" rel="stylesheet" type="text/css">
	<style>
	<!--
	FONT {
	FONT-SIZE: 9.5pt;
	FONT-FAMILY: "Courier New", Courier, monospace;
	-->
	</style>
	<META http-equiv=Content-Type content="text/html; charset=windows-1251">
    <script language=JavaScript src="engine.js"></script>
    <script language=JavaScript>
    <!--
    menu("Roguelike Development");
    //--></script>
<font color="BBBBBB" class="def">
<div align="center"><h1>Roguelike Development.</h1>
<h2>Поле зрения в roguelike-игре</h2>
</div>
</font>
<font color="BBBBBB" class="Article">

Одна из основных задач, возникающих при создании Roguelike-игры - программирование так называемого LoS (Line of Sight - 
поле зрения). В этой статье я опишу основные способы программирования LoS.<br>
Итак, существует несколько разных подходов к обсчету поля видимости, но в любом случае вам придется хранить boolean 
массив-маску, в который вы и будете записывать результаты подсчетов.<br>
Первый способ основан на том, что если мы видим предмет, то это значит, что:<br>
1. Предмет находится неподалеку от нас.<br>
2. На прямой, соединяющей наш глаз и предмет не находится непрозрачных тел (про зеркала разговор отдельный, но я не видел ни 
одной roguelike-игры, где бы присутствовали зеркала).<br>
Из этих двух рассуждений сразу вытекает схема алгоритма - мы будем строить прямую от персонажа до каждой клетки уровня, и если 
эта прямая ничего не пересекает, то считать обрабатываемую клетку видимой. Однако есть несколько важных нюансов, отличающих 
алгоритмы этой группы друг от друга. <br>
Во-первых, персонаж в кромешной тьме подземелья наверняка не сможет увидеть орка, стоящего в противоположном конце длинной 
колоннады. То есть нужно ввести такой параметр как радиус видимости. Просчитывать видимость мы будем только для квадрата 
с центром в местоположении персонажа и со сторонами равными 1+2R, где R - радиус видимости. Вычислять по теореме пифагора 
расстояние до персонажа от каждой клетки этого квадрата нерационально. Проще завести заранее подсчитанный массив растояний:<br>
<pre>
          7 
        6 6 7
      4 5 6 7
    3 4 4 5 6 7
  1 2 3 4 5 6 7
<font color="#008000">@</font> 1 2 3 4 5 6 7 ...
</pre>
Здесь @ - место, где стоит персонаж, а цифры - округленное расстояние от персонажа до данной клетки. Понятно, что достаточно 
создать такой массив лишь для 1/8 части окружности, ведь для всех остальных частей этот массив можно получить отражением (замена 
x на y и умножение x и/или y на -1). Теперь, получив расстояние от персонажа до обсчитываемой клетки по x и по y, мы сравниваем 
радиус видимости и соответствующий элемент нашего массива. Если элемент меньше либо равен радиусу, то клетка потенциально видима.<br>
Во-вторых, если вы будете "честно" просчитывать пересечения луча и клеток, то, зайдя в тупиковый коридор, увидите примерно 
следующее:<br>
<br>
<font color="#808080">#######</font>? <br>
<font color="#c0c0c0">.</font><font color="#008000">@</font><font color="#c0c0c0">.....</font><font color="#808080">#</font><br>
<font color="#808080">#######</font>?<br>
<font color="#808080">#</font> - стена<br>
<font color="#c0c0c0">.</font> - пол<br>
<font color="#008000">@</font> - персонаж<br>
? - невидимая область<br>
<br>
А ведь во всех roguelike, в которые вы до этого играли, все выглядело несколько по-другому:<br>
<br>
<font color="#808080">########</font><br>
<font color="#c0c0c0">.</font><font color="#008000">@</font><font color="#c0c0c0">.....</font><font color="#808080">#</font><br>
<font color="#808080">########</font><br>
<br>
Существует много способов борьбы с этим неприятным явлением. Я опишу лишь самый простой и наиболее ресурсоемкий.<br>
Все гениальное просто - сказал кто-то из великих, и был совершенно прав. Мы будем выпускать не ОДИН, а ДВА луча, первый с 
округлением вверх, второй с округлением вниз, оба с шагом 1 по большей оси. Выглядеть это будет так:<br>
<pre>
Округляемый вверх,    Округляемый вниз,
Первый луч:           Второй луч:
<font color="#808080">#########</font><font color="#ffff00">**X</font><font color="#808080">          ###########</font><font color="#ffff00">X</font>
<font color="#ffff00">      ***  </font><font color="#808080">#</font><font color="#ffff00">                   **</font><font color="#808080">#</font>
<font color="#ffff00">   ***     </font><font color="#808080">#</font><font color="#ffff00">                ***  </font><font color="#808080">#</font>
<font color="#ffff00"> **        </font><font color="#808080">#</font><font color="#ffff00">             ***     </font><font color="#808080">#</font>
<font color="#008000">@          </font><font color="#808080">#</font><font color="#008000">          @</font><font color="#ffff00">**        </font><font color="#808080">#</font>
</pre>
Первый луч врезался в стену на пути к углу, зато второй зашел точно в угол. То есть если мы видим обьект хотя бы одним 
лучом, то помечаем его как видимый. Если же вам такая схема не по душе, то я напомню, что у человека тоже ДВА глаза - был 
бы один, глядишь, также глючили бы :-).<br>
<br>
В-третьих, выпускать луч в каждую клетку вовсе не обязательно, ведь уже первый луч пройдет по многим клеткам, а это значит, 
что они видимы, и второй раз обсчитывать их не надо.<br>
<br>
В-четвертых, если один из лучей прошел по какой-либо клетке, вляпавшись перед этим в стену, то это вовсе не значит, что эта 
клетка не видима. Просто этот конкректный луч не увидел ее. Приведу пример:<br>
<pre>
<font color="#ffff00">       ---</font><font color="#808080"> #</font> - стена, в которую врезался луч
<font color="#808080">    #</font><font color="#ffff00">-X</font><font color="#008000">    @</font> - персонаж
<font color="#ffff00"> ***       *</font> - клетки, видимые лучем
<font color="#008000">@          </font><font color="#ffff00">-</font> - клетки, лежащие на луче, но не видимые им
</pre>
Вот наш луч врезался в стену, и мы считаем, что клетка, помеченная крестиком, не видима. Однако это не так!<br>
<pre>
<font color="#808080">    #</font><font color="#ffff00">*X</font>
<font color="#ffff00">   **</font>
<font color="#008000">@</font><font color="#ffff00">**</font>
</pre>
Стоит провести луч прямиком в нашу клетку, и оказывается, что она видима!!! Мы пришли к выводу, что о невидимости какой-либо
 клетки мы можем судить только после завершения работы алгоритма.<br>
<br>
И еще - клетки, лежащие на вертикали, горизонтали и диагоналях относительно игрока, надо обсчитать отдельно, выпустив в 
каждое из этих восьми направлений по ОДНОМУ лучу. Причем все клетки, лежищие на этих прямых, и не видимые этими восемью 
лучами, можно однозначно считать невидимыми. Это исключение из правила. Пример:<br>
<pre>
<font color="#ffff00">   * * *         </font>   Клетки, отмеченные знаком
<font color="#ffff00">    ***          </font>   минус точно невидимы.
<font color="#ffff00">*****</font><font color="#008000">@</font><font color="#ffff00">*****</font><font color="#808080">#</font><font color="#ffff00">-----</font>
<font color="#ffff00">    *** </font>
<font color="#ffff00">   * * *</font>
</pre>
Описанный выше алгоритм называют ray-casting (или ray-tracing) алгоритмом. Основное его отличие - он вычисляет ВИДИМЫЕ 
клетки, а остальные считает невидимыми. Однако есть еще один алгоритм, который, напротив, находит НЕВИДИМЫЕ области, а 
все остальное считает видимым. Это shadow-casting. Подробно я его описывать не буду, потому что сам с ним знаком весьма
поверхностно. Некоторые говорят, что с некоторыми оптимизацияи он требует O(n) памяти, в отличие от ray-casting'а, 
который гораздо прожорливее и требует O(n^2) памяти. Однако это означает, что мы не будем хранить в памяти нашу любимую 
маску видимости, что лично мне очень не нравится. Но основная причина того, что этот алгоритм еще жив, состоит в том,
что после незначительных изменений с его помощью можно разделять клетки не просто на видимые и невидимые, но также и на
частично видимые (при желании для каждой клетки можно вычислять процент видимости).<br>
Идея алгоритма проста - мы считаем, что у игрока один-единственный глаз (играйте циклопом, товарищи!), расположенный в 
центе клетки, в которой он находится, и имеющий радиус обзора 360 градусов (хмм... это уже больше смахивает на бехолдера :-). 
Мы последовательно рассматриваем клетки-стены, расположенные рядом с игроком, и для каждой такой клетки строим угол с 
центром в глазе персонажа, целиком содержащий эту клетку. Пример:<br>
<pre>
                              ____________
                              |          <font color="#ffff00">*</font>
                              |       <font color="#ffff00">***</font>|
                              |     <font color="#ffff00">**</font>   |
                              |   <font color="#ffff00">**</font>     |
                   ___________|<font color="#ffff00">***</font>_______|
                   |         <font color="#ffff00">**</font><font color="#808080">##########</font>|
                   |       <font color="#ffff00">**</font> |<font color="#808080">##########</font>|
                   |    <font color="#ffff00">***</font>   |<font color="#808080">##########</font>|
                   |  <font color="#ffff00">**</font>      |<font color="#808080">##########</font>|
        ___________|<font color="#ffff00">**</font>________|<font color="#808080">##########</font>|<font color="#ffff00">*****</font>
        |        <font color="#ffff00">***</font>          |  <font color="#ffff00">*********</font>
        |      <font color="#ffff00">**</font>  |   <font color="#ffff00">**********</font>        |
        |    <font color="#ffff00">**********</font>       |          |
        |          |          |          |
        |__________|__________|__________|
</pre>
Получившийся угол "стягивает" клетку и теперь все, что в нем содержится, и находится дальше этой стены, можно с уверенностью 
считать невидимым. Принадлежность клетки углу проверяется без проблем. Вычислительная сложность такого алгоритма несколько 
больше, чем у ray-casting, но он тоже имеет свои преимущества.<br>
<br>
И еще один полезный совет. Если вы работаете с консолью, а не с DirectX, то не надо каждый раз перевыводить на экран всю 
область видимости, совершая много лишней работы. Пример:<br>
<pre>
-------------------
-------------------
------.......------
-----.........-----
----...........----
----...........----
----...........----
----.....<font color="#008000">@</font>.....----    Игрок, стоящий в чистом поле,
----...........----    имеет радиус видимости 5.
----...........----    . - видимые клетки.
----...........----    - - невидимые клетки.
-----.........-----
------.......------
-------------------
-------------------
</pre>
Теперь игрок делает шаг на юг (вниз):<br>
<pre>
-------------------
-------------------
------:::::::------
-----:XXXXXXX:-----
----:XXXXXXXXX:----
----XXXXXXXXXXX----
----XXXXXXXXXXX----
----XXXXXXXXXXX----
----XXXXX<font color="#008000">@</font>XXXXX----
----XXXXXXXXXXX----    : - клетки, ставшие невидимыми.
----XXXXXXXXXXX----    X - по прежнему видимые клетки.
----<font color="#ffff00">*</font>XXXXXXXXX<font color="#ffff00">*</font>----    - - невидимые клетки.
-----<font color="#ffff00">*</font>XXXXXXX<font color="#ffff00">*</font>-----    <font color="#ffff00">*</font> - клетки, которые мы только что увидели.
------<font color="#ffff00">*******</font>------
-------------------
-------------------
</pre>
Стандартный алгоритм заново перерисует целых 98 клеток, в то время как игрок на экране заметит, что изменились лишь 11 клеток. 
Так зачем же делать лишнюю работу? Просто не будем выводить не измененные клетки.<br>
<br>
Брр... вот и все. Печаталось это в спешке, поэтому возможны опечатки.
<br>
<br>
Автор статьи: Фокин Александр aka [ArX]Elric!<br>
e-mail: <a href="mailto:elric2002@mail.ru">elric2002@mail.ru</a><br>
Сайт:<script language=JavaScript>
<!--
homesite();
//--></script><br>
Этот материал распространяется свободно. See the Free Software Foundation's GNU General Public License Version 2 for 
details.<br>


</font>
    <script language=JavaScript>
    <!--
    endmenu();
    //--></script>
</body>
</html>